{"version":3,"sources":["../../src/lib/flow.js"],"names":["flowCommandPath","projectDir","tmpDirPath","tmpFilePath","process","env","VERBOSE","temp","path","suffix","dir","cwd","maxBuffer","Infinity","dontReject","res","err","code","console","error","stderr","stdout","statusData","log","JSON","parse","String","unexpectedException","Error","flowVersion","checkFlowStatus","flowCommandTimeout","filename","strictCoverage","emptyCoverageData","annotation","expressions","covered_count","uncovered_count","uncovered_locs","escapeFileName","timeout","percent","NaN","isError","flowCoverageError","undefined","flowCoverageException","message","flowCoverageStderr","flowCoverageParsingError","parsedData","collectFlowCoverageForFile","getCoveredPercent","summarizeAnnotations","collectFlowCoverage","Array","prototype","find","require","shim","fileName","replace","total","Math","floor","coverageSummaryData","flowFiles","flowWeakFiles","noFlowFiles","filenames","Object","keys","files","forEach","passed","totalFiles","length","globIncludePatterns","globExcludePatterns","threshold","concurrentFiles","excludeNonFlow","then","waitForCollectedDataFromFiles","Promise","all","drainQueue","now","Date","coverageGeneratedAt","toDateString","toTimeString","annotationSummary","generatedAt","flowStatus","flowAnnotations","cleanupUncoveredLoc","loc","start","source","end","collectCoverageAndGenerateReportForGlob","globIncludePattern","root","pattern","push","data","map"],"mappings":"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","file":"flow.js","sourcesContent":["'use strict';\n\n// @flow\n\nimport minimatch from 'minimatch';\nimport temp from 'temp';\nimport {genCheckFlowStatus} from 'flow-annotation-check';\nimport {exec, glob, writeFile} from './promisified';\n\n// Load the Array.prototype.find polyfill if needed (e.g. nodejs 0.12).\n/* istanbul ignore if  */\nif (!Array.prototype.find) {\n  require('array.prototype.find').shim();\n}\n\n// Escape special characters in file names.\nexport function escapeFileName(fileName: string): string {\n  return fileName.replace(/([\"\\s'$`\\\\])/g, '\\\\$1');\n}\n\n/* eslint-disable camelcase */\nexport function getCoveredPercent(\n  {\n    covered_count, uncovered_count\n  }: {\n    covered_count: number, uncovered_count: number\n  }\n) {\n  const total = covered_count + uncovered_count;\n\n  if (total === 0) {\n    return 100;\n  }\n\n  return Math.floor(covered_count / total * 100);\n}\n/* eslint-disable-line camelcase */\n\n// Definitions and flow types related to checkFlowStatus.\n\nexport type FlowTypeErrorPosition = {\n  offset: number,\n  column: number,\n  line: number\n}\n\nexport type FlowTypeErrorMessage = {\n  type: string,\n  start: number,\n  end: number,\n  line: number,\n  endline: number,\n  path: string,\n  descr: string,\n  context?: string,\n  loc?: {\n    start: FlowTypeErrorPosition,\n    end: FlowTypeErrorPosition,\n    type: string,\n    source: string\n  }\n}\n\nexport type FlowTypeError = {\n  kind: string,\n  level: string,\n  message: Array<FlowTypeErrorMessage>\n}\n\nexport type FlowStatus = {\n  passed: boolean,\n  flowVersion: string,\n  errors: Array<FlowTypeError>\n}\n\nexport async function checkFlowStatus(\n  flowCommandPath: string,\n  projectDir: string,\n  tmpDirPath: ?string\n): Promise<FlowStatus> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path(tmpDirPath ?\n      {suffix: '.json', dir: tmpDirPath} : {suffix: '.json'});\n  }\n\n  const res = await exec(`${flowCommandPath} status --json`,\n                         {cwd: projectDir, maxBuffer: Infinity},\n                         {dontReject: true});\n\n  if (res.err && res.err.code !== 2) {\n    if (process.env.VERBOSE) {\n      console.error('Flow status error', res.err, res.stderr, res.stdout);\n    }\n\n    throw res.err;\n  }\n\n  let statusData: ?FlowStatus;\n\n  if (tmpFilePath) {\n    await writeFile(tmpFilePath, res.stdout || '');\n    console.log('Flow status result saved to', tmpFilePath);\n  }\n\n  try {\n    statusData = JSON.parse(String(res.stdout));\n  } catch (err) {\n    const unexpectedException: ?SyntaxError = err;\n\n    // Verify the integrity of the format of the JSON status result.\n    if (unexpectedException) {\n      throw new Error(`Parsing error on Flow status JSON result: ${err}`);\n    }\n  }\n\n  if (statusData && statusData.flowVersion) {\n    return statusData;\n  }\n\n  throw new Error('Invalid Flow status JSON format');\n}\n\n// Definitions and flow types related to collectFlowCoverageForFile.\n\nexport type FlowUncoveredPos = {\n  line: number,\n  column: number,\n  offset: number,\n  source: string\n}\n\nexport type FlowUncoveredLoc = {\n  start: FlowUncoveredPos,\n  end: FlowUncoveredPos\n}\n\nexport type FlowCoverageJSONData = {\n  expressions: {\n    covered_count: number,\n    uncovered_count: number,\n    uncovered_locs: Array<FlowUncoveredLoc>\n  },\n  filename?: string,\n  annotation?: 'no flow' | 'flow weak' | 'flow',\n  percent: number,\n  error?: string,\n  isError?: boolean,\n  flowCoverageError?: ?string,\n  flowCoverageException?: ?string,\n  flowCoverageParsingError?: ?string,\n  flowCoverageStderr?: string|Buffer\n}\n\nexport async function collectFlowCoverageForFile(\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  filename: string,\n  tmpDirPath: ?string,\n  strictCoverage: ?boolean,\n): Promise<FlowCoverageJSONData> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path(tmpDirPath ?\n      {suffix: '.json', dir: tmpDirPath} : {suffix: '.json'});\n  }\n\n  const emptyCoverageData = {\n    filename,\n    annotation: 'no flow',\n    expressions: {\n      covered_count: 0,\n      uncovered_count: 0,\n      uncovered_locs: []\n    }\n  };\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} (timeouts in ${flowCommandTimeout})...`);\n  }\n\n  const res = await exec(\n    `${flowCommandPath} coverage --json ${escapeFileName(filename)}`,\n    // NOTE: set a default timeouts and maxButter to Infinity to prevent,\n    // misconfigured projects and source files that should raises errors\n    // or hangs the flow daemon to prevent the coverage reporter to complete\n    // the data collection. (See https://github.com/rpl/flow-coverage-report/pull/4\n    // and https://github.com/rpl/flow-coverage-report/pull/5 for rationale,\n    // thanks to to @mynameiswhm and @ryan953  for their help on hunting down this issue)\n    {cwd: projectDir, timeout: flowCommandTimeout, maxBuffer: Infinity},\n    {dontReject: true});\n\n  if (res.err) {\n    console.error(`ERROR Collecting coverage data from ${filename} `, filename, res.err, res.stderr);\n\n    if (process.env.VERBOSE) {\n      if (tmpFilePath) {\n        await writeFile(tmpFilePath, res.stdout || '');\n      }\n    }\n\n    // TODO: collect errors and put them in a visible place in the\n    // generated report.\n    return {\n      ...emptyCoverageData,\n      percent: NaN,\n      isError: true,\n      flowCoverageError: undefined,\n      flowCoverageException: res.err && res.err.message,\n      flowCoverageStderr: res.stderr,\n      flowCoverageParsingError: undefined\n    };\n  }\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} completed.`);\n    if (tmpFilePath) {\n      await writeFile(tmpFilePath, res.stdout || '');\n      console.log(`Saved json dump of collected coverage data from ${filename} to ${tmpFilePath}.`);\n    }\n  }\n\n  let parsedData: ?FlowCoverageJSONData;\n  let flowCoverageParsingError: string;\n\n  if (res.stdout) {\n    try {\n      parsedData = JSON.parse(String(res.stdout));\n    } catch (err) {\n      flowCoverageParsingError = err.message;\n    }\n  }\n\n  if (res.stderr) {\n    try {\n      parsedData = JSON.parse(String(res.stderr));\n      delete res.stderr;\n    } catch (err) {\n    }\n  }\n\n  if (parsedData && !parsedData.error) {\n    parsedData.filename = filename;\n    parsedData.annotation = await genCheckFlowStatus(flowCommandPath, filename);\n\n    // In strictCoverage mode all files that are not strictly flow\n    // (e.g. non annotated and flow weak files) are considered\n    // as completely uncovered.\n    if (strictCoverage && parsedData.annotation !== 'flow') {\n      parsedData.expressions.uncovered_count += parsedData.expressions.covered_count;\n      parsedData.expressions.covered_count = 0;\n    }\n    return parsedData;\n  }\n\n  return {\n    ...emptyCoverageData,\n    percent: NaN,\n    isError: true,\n    flowCoverageError: parsedData && parsedData.error,\n    flowCoverageException: undefined,\n    flowCoverageParsingError,\n    flowCoverageStderr: res.stderr\n  };\n}\n\n// Definition and flow types related to collectForCoverage.\n\ntype FlowAnnotationSummary = {\n  passed: boolean,\n  flowFiles: number,\n  flowWeakFiles: number,\n  noFlowFiles: number,\n  totalFiles: number,\n};\n\nexport type FlowCoverageSummaryData = {\n  covered_count: number,\n  uncovered_count: number,\n  percent: number,\n  threshold: number,\n  generatedAt: string,\n  flowStatus: FlowStatus,\n  flowAnnotations: FlowAnnotationSummary,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  concurrentFiles: number,\n  files: {\n    [key: string]: FlowCoverageJSONData\n  }\n}\n\nexport function summarizeAnnotations(\n  coverageSummaryData: FlowCoverageSummaryData\n): FlowAnnotationSummary {\n  let flowFiles = 0;\n  let flowWeakFiles = 0;\n  let noFlowFiles = 0;\n\n  const filenames = Object.keys(coverageSummaryData.files);\n\n  filenames.forEach(filename => {\n    switch (coverageSummaryData.files[filename].annotation) {\n      case 'flow':\n        flowFiles += 1;\n        break;\n      case 'flow weak':\n        flowWeakFiles += 1;\n        break;\n      case 'no flow':\n        noFlowFiles += 1;\n        break;\n      default:\n        throw new Error(`Unexpected missing flow annotation on ${filename}`);\n    }\n  });\n\n  return {\n    passed: (flowWeakFiles + noFlowFiles) === 0,\n    flowFiles,\n    flowWeakFiles,\n    noFlowFiles,\n    totalFiles: filenames.length\n  };\n}\n\nexport function collectFlowCoverage(\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  threshold: number,\n  concurrentFiles: number,\n  tmpDirPath: ?string,\n  strictCoverage: ?boolean,\n  excludeNonFlow: boolean\n): Promise<FlowCoverageSummaryData> {\n  return checkFlowStatus(flowCommandPath, projectDir, tmpDirPath).then(flowStatus => {\n    const now = new Date();\n    const coverageGeneratedAt = now.toDateString() + ' ' + now.toTimeString();\n\n    const annotationSummary = {\n      passed: false,\n      flowFiles: 0,\n      flowWeakFiles: 0,\n      noFlowFiles: 0,\n      totalFiles: 0\n    };\n\n    const coverageSummaryData: FlowCoverageSummaryData = {\n      threshold,\n      covered_count: 0, uncovered_count: 0, // eslint-disable-line camelcase\n      percent: 0,\n      generatedAt: coverageGeneratedAt,\n      flowStatus,\n      flowAnnotations: annotationSummary,\n      files: {},\n      globIncludePatterns,\n      globExcludePatterns,\n      concurrentFiles,\n      strictCoverage,\n      excludeNonFlow\n    };\n\n    // Remove the source attribute from all ucovered_locs entry.\n    function cleanupUncoveredLoc(loc) {\n      delete loc.start.source;\n      delete loc.end.source;\n      return loc;\n    }\n\n    let waitForCollectedDataFromFiles = [];\n\n    async function drainQueue() {\n      if (process.env.VERBOSE) {\n        console.log(`Wait for ${waitForCollectedDataFromFiles.length} queued files.`);\n      }\n      // Wait the queued files.\n      await Promise.all(waitForCollectedDataFromFiles);\n      // Empty the collected Data From files queue.\n      waitForCollectedDataFromFiles = [];\n    }\n\n    function collectCoverageAndGenerateReportForGlob(globIncludePattern) {\n      return glob(globIncludePattern, {cwd: projectDir, root: projectDir})\n        .then(async files => {\n          for (const filename of files) {\n            // Skip files that match any of the exclude patterns.\n            if (globExcludePatterns.find(pattern => minimatch(filename, pattern)) !== undefined) {\n              if (process.env.VERBOSE) {\n                console.log(`Skip ${filename}, matched excluded pattern.`);\n              }\n              continue;\n            }\n\n            if (excludeNonFlow) {\n              // eslint-disable-next-line no-await-in-loop\n              const annotation = await genCheckFlowStatus(flowCommandPath, filename);\n              if (annotation === 'no flow') {\n                if (process.env.VERBOSE) {\n                  console.log(`Skip ${filename}, matched 'no flow' in excludeNonFlow mode.`);\n                }\n                continue;\n              }\n            }\n\n            if (process.env.VERBOSE) {\n              console.log(`Queue ${filename} flow coverage data collection`);\n            }\n\n            waitForCollectedDataFromFiles.push(collectFlowCoverageForFile(\n              flowCommandPath, flowCommandTimeout, projectDir, filename, tmpDirPath, strictCoverage\n            ).then(data => {\n              /* eslint-disable camelcase */\n              coverageSummaryData.covered_count += data.expressions.covered_count;\n              coverageSummaryData.uncovered_count += data.expressions.uncovered_count;\n              data.percent = getCoveredPercent(data.expressions);\n\n              if (!data.filename) {\n                throw new Error('Unxepected missing filename from collected coverage data');\n              }\n\n              coverageSummaryData.files[data.filename] = data;\n\n              data.expressions.uncovered_locs =\n                data.expressions.uncovered_locs.map(cleanupUncoveredLoc);\n              /* eslint-enable camelcase */\n            }));\n\n            // If we have collected at least `concurrentFiles` number of files,\n            // wait the queue to be drained.\n            if (waitForCollectedDataFromFiles.length >= concurrentFiles) {\n              await drainQueue(); // eslint-disable-line no-await-in-loop\n            }\n          }\n\n          // Wait for any remaining queued file.\n          if (waitForCollectedDataFromFiles.length > 0) {\n            await drainQueue();\n          }\n\n          return files;\n        });\n    }\n\n    return Promise\n      .all(globIncludePatterns.map(collectCoverageAndGenerateReportForGlob))\n      .then(() => {\n        coverageSummaryData.percent = getCoveredPercent(coverageSummaryData);\n        coverageSummaryData.flowAnnotations = summarizeAnnotations(\n          coverageSummaryData\n        );\n\n        return coverageSummaryData;\n      });\n  });\n}\n"]}